import { Injectable, Logger } from '@nestjs/common';
import * as net from 'net';
import * as dns from 'dns';
import { promisify } from 'util';

export interface PortScanResult {
  port: number;
  status: 'open' | 'closed' | 'filtered';
  service?: string;
  version?: string;
  banner?: string;
  vulnerability?: string;
  scanTime: number;
}

export interface NetworkScanResult {
  host: string;
  ip: string;
  ports: PortScanResult[];
  totalOpenPorts: number;
  scanDuration: number;
  timestamp: Date;
}

@Injectable()
export class PortScannerService {
  private readonly logger = new Logger(PortScannerService.name);
  private readonly commonPorts = [
    21, 22, 23, 25, 53, 80, 110, 143, 443, 993, 995, 3306, 5432, 6379, 8080, 8443
  ];

  private readonly serviceSignatures = {
    21: 'FTP',
    22: 'SSH',
    23: 'Telnet',
    25: 'SMTP',
    53: 'DNS',
    80: 'HTTP',
    110: 'POP3',
    143: 'IMAP',
    443: 'HTTPS',
    993: 'IMAPS',
    995: 'POP3S',
    3306: 'MySQL',
    5432: 'PostgreSQL',
    6379: 'Redis',
    8080: 'HTTP-Alt',
    8443: 'HTTPS-Alt',
  };

  /**
   * Escanea un host completo
   */
  async scanHost(host: string, ports?: number[]): Promise<NetworkScanResult> {
    const startTime = Date.now();
    this.logger.log(`üîç Starting port scan for host: ${host}`);

    try {
      const ip = await this.resolveHostname(host);
      const portsToScan = ports || this.commonPorts;
      
      const portResults = await Promise.allSettled(
        portsToScan.map(port => this.scanPort(ip, port))
      );

      const results = portResults
        .filter(result => result.status === 'fulfilled')
        .map(result => (result as PromiseFulfilledResult<PortScanResult>).value);

      const openPorts = results.filter(r => r.status === 'open');
      
      const scanResult: NetworkScanResult = {
        host,
        ip,
        ports: results,
        totalOpenPorts: openPorts.length,
        scanDuration: Date.now() - startTime,
        timestamp: new Date(),
      };

      this.logger.log(`‚úÖ Port scan completed for ${host}: ${openPorts.length} open ports found`);
      return scanResult;

    } catch (error) {
      this.logger.error(`‚ùå Port scan failed for ${host}: ${error.message}`);
      throw error;
    }
  }

  /**
   * Escanea un puerto espec√≠fico
   */
  async scanPort(host: string, port: number, timeout: number = 5000): Promise<PortScanResult> {
    const startTime = Date.now();
    
    return new Promise((resolve) => {
      const socket = new net.Socket();
      let result: PortScanResult = {
        port,
        status: 'closed',
        scanTime: 0,
      };

      socket.setTimeout(timeout);

      socket.on('connect', async () => {
        result.status = 'open';
        result.scanTime = Date.now() - startTime;
        
        // Intentar obtener banner del servicio
        try {
          const banner = await this.getServiceBanner(socket, port);
          result.banner = banner;
          result.service = this.serviceSignatures[port] || 'Unknown';
        } catch (error) {
          result.service = this.serviceSignatures[port] || 'Unknown';
        }

        socket.destroy();
        resolve(result);
      });

      socket.on('timeout', () => {
        result.status = 'filtered';
        result.scanTime = Date.now() - startTime;
        socket.destroy();
        resolve(result);
      });

      socket.on('error', () => {
        result.status = 'closed';
        result.scanTime = Date.now() - startTime;
        socket.destroy();
        resolve(result);
      });

      socket.connect(port, host);
    });
  }

  /**
   * Escaneo r√°pido de puertos comunes
   */
  async quickScan(host: string): Promise<NetworkScanResult> {
    const quickPorts = [22, 80, 443, 3306, 5432, 8080];
    return this.scanHost(host, quickPorts);
  }

  /**
   * Escaneo completo de todos los puertos
   */
  async fullScan(host: string): Promise<NetworkScanResult> {
    const allPorts = Array.from({ length: 65535 }, (_, i) => i + 1);
    return this.scanHost(host, allPorts);
  }

  /**
   * Escaneo de rangos de puertos espec√≠ficos
   */
  async rangeScan(host: string, startPort: number, endPort: number): Promise<NetworkScanResult> {
    const ports = Array.from(
      { length: endPort - startPort + 1 }, 
      (_, i) => startPort + i
    );
    return this.scanHost(host, ports);
  }

  /**
   * Resuelve hostname a IP
   */
  private async resolveHostname(hostname: string): Promise<string> {
    try {
      const resolve4 = promisify(dns.resolve4);
      const addresses = await resolve4(hostname);
      return addresses[0];
    } catch (error) {
      // Si no se puede resolver, asumir que ya es una IP
      return hostname;
    }
  }

  /**
   * Obtiene banner del servicio
   */
  private async getServiceBanner(socket: net.Socket, port: number): Promise<string> {
    return new Promise((resolve, reject) => {
      let banner = '';
      
      socket.on('data', (data) => {
        banner += data.toString();
        if (banner.length > 1024) {
          socket.destroy();
          resolve(banner.substring(0, 1024));
        }
      });

      socket.on('error', () => {
        resolve(banner);
      });

      socket.on('close', () => {
        resolve(banner);
      });

      // Enviar comandos espec√≠ficos seg√∫n el puerto
      setTimeout(() => {
        switch (port) {
          case 22:
            socket.write('\r\n');
            break;
          case 80:
            socket.write('GET / HTTP/1.1\r\nHost: localhost\r\n\r\n');
            break;
          case 443:
            socket.write('GET / HTTP/1.1\r\nHost: localhost\r\n\r\n');
            break;
          default:
            socket.write('\r\n');
        }
      }, 100);
    });
  }

  /**
   * Analiza vulnerabilidades en puertos abiertos
   */
  async analyzeVulnerabilities(scanResult: NetworkScanResult): Promise<any> {
    const vulnerabilities = [];

    for (const port of scanResult.ports) {
      if (port.status === 'open') {
        const vuln = this.checkPortVulnerabilities(port);
        if (vuln) {
          vulnerabilities.push(vuln);
        }
      }
    }

    return {
      host: scanResult.host,
      vulnerabilities,
      riskLevel: this.calculateRiskLevel(vulnerabilities),
      recommendations: this.generateRecommendations(vulnerabilities),
    };
  }

  /**
   * Verifica vulnerabilidades espec√≠ficas por puerto
   */
  private checkPortVulnerabilities(port: PortScanResult): any {
    const commonVulns = {
      21: 'FTP anonymous access possible',
      23: 'Telnet is insecure - use SSH instead',
      80: 'HTTP without HTTPS - consider SSL/TLS',
      143: 'IMAP without encryption - use IMAPS',
      3306: 'MySQL exposed - restrict access',
      5432: 'PostgreSQL exposed - restrict access',
      6379: 'Redis exposed - restrict access',
    };

    if (commonVulns[port.port]) {
      return {
        port: port.port,
        service: port.service,
        vulnerability: commonVulns[port.port],
        severity: this.getSeverity(port.port),
      };
    }

    return null;
  }

  /**
   * Calcula nivel de riesgo
   */
  private calculateRiskLevel(vulnerabilities: any[]): string {
    const highRisk = vulnerabilities.filter(v => v.severity === 'HIGH').length;
    const mediumRisk = vulnerabilities.filter(v => v.severity === 'MEDIUM').length;
    const lowRisk = vulnerabilities.filter(v => v.severity === 'LOW').length;

    if (highRisk > 0) return 'HIGH';
    if (mediumRisk > 2) return 'MEDIUM';
    if (lowRisk > 5) return 'LOW';
    return 'MINIMAL';
  }

  /**
   * Obtiene severidad de vulnerabilidad
   */
  private getSeverity(port: number): string {
    const highRiskPorts = [21, 23, 3306, 5432, 6379];
    const mediumRiskPorts = [80, 143, 8080];

    if (highRiskPorts.includes(port)) return 'HIGH';
    if (mediumRiskPorts.includes(port)) return 'MEDIUM';
    return 'LOW';
  }

  /**
   * Genera recomendaciones de seguridad
   */
  private generateRecommendations(vulnerabilities: any[]): string[] {
    const recommendations = [];

    if (vulnerabilities.some(v => v.port === 21)) {
      recommendations.push('Disable anonymous FTP access');
    }

    if (vulnerabilities.some(v => v.port === 23)) {
      recommendations.push('Replace Telnet with SSH');
    }

    if (vulnerabilities.some(v => v.port === 80)) {
      recommendations.push('Implement HTTPS with valid SSL certificate');
    }

    if (vulnerabilities.some(v => [3306, 5432, 6379].includes(v.port))) {
      recommendations.push('Restrict database access to specific IPs');
    }

    if (vulnerabilities.length > 0) {
      recommendations.push('Implement firewall rules to block unnecessary ports');
      recommendations.push('Regular security audits and penetration testing');
    }

    return recommendations;
  }
} 