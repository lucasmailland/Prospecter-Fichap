import {
  Controller,
  Post,
  Get,
  Body,
  Query,
  UseGuards,
  HttpCode,
  HttpStatus,
  BadRequestException,
} from '@nestjs/common';
import { ApiTags, ApiOperation, ApiResponse, ApiBearerAuth, ApiQuery } from '@nestjs/swagger';
import { JwtAuthGuard } from '../../auth/guards/jwt-auth.guard';
import { PentestService } from './pentest.service';
import { PortScannerService } from './services/port-scanner.service';
import { VulnerabilityScannerService } from './services/vulnerability-scanner.service';

export class ScanTargetDto {
  target: string;
  scanType?: 'quick' | 'full' | 'custom';
  ports?: number[];
}

export class VulnerabilityScanDto {
  target: string;
  scanTypes?: string[];
}

@ApiTags('pentest')
@Controller('pentest')
@UseGuards(JwtAuthGuard)
@ApiBearerAuth()
export class PentestController {
  constructor(
    private readonly pentestService: PentestService,
    private readonly portScannerService: PortScannerService,
    private readonly vulnerabilityScannerService: VulnerabilityScannerService,
  ) {}

  @Post('port-scan')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({
    summary: 'Escaneo de puertos',
    description: 'Realiza un escaneo completo de puertos en un host objetivo',
  })
  @ApiResponse({
    status: 200,
    description: 'Escaneo de puertos completado',
  })
  @ApiResponse({
    status: 400,
    description: 'Target inválido',
  })
  @ApiResponse({
    status: 401,
    description: 'No autorizado',
  })
  async portScan(@Body() scanDto: ScanTargetDto) {
    if (!scanDto.target) {
      throw new BadRequestException('Target is required');
    }

    let scanResult;
    switch (scanDto.scanType) {
      case 'quick':
        scanResult = await this.portScannerService.quickScan(scanDto.target);
        break;
      case 'full':
        scanResult = await this.portScannerService.fullScan(scanDto.target);
        break;
      case 'custom':
        if (!scanDto.ports || scanDto.ports.length === 0) {
          throw new BadRequestException('Ports array is required for custom scan');
        }
        scanResult = await this.portScannerService.scanHost(scanDto.target, scanDto.ports);
        break;
      default:
        scanResult = await this.portScannerService.scanHost(scanDto.target);
    }

    // Analizar vulnerabilidades en puertos abiertos
    const vulnerabilityAnalysis = await this.portScannerService.analyzeVulnerabilities(scanResult);

    return {
      ...scanResult,
      vulnerabilityAnalysis,
    };
  }

  @Post('vulnerability-scan')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({
    summary: 'Escaneo de vulnerabilidades',
    description: 'Realiza un escaneo completo de vulnerabilidades web',
  })
  @ApiResponse({
    status: 200,
    description: 'Escaneo de vulnerabilidades completado',
  })
  @ApiResponse({
    status: 400,
    description: 'Target inválido',
  })
  @ApiResponse({
    status: 401,
    description: 'No autorizado',
  })
  async vulnerabilityScan(@Body() scanDto: VulnerabilityScanDto) {
    if (!scanDto.target) {
      throw new BadRequestException('Target is required');
    }

    return await this.vulnerabilityScannerService.scanTarget(scanDto.target);
  }

  @Post('full-pentest')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({
    summary: 'Pentest completo',
    description: 'Realiza un pentest completo incluyendo escaneo de puertos y vulnerabilidades',
  })
  @ApiResponse({
    status: 200,
    description: 'Pentest completo finalizado',
  })
  @ApiResponse({
    status: 400,
    description: 'Target inválido',
  })
  @ApiResponse({
    status: 401,
    description: 'No autorizado',
  })
  async fullPentest(@Body() scanDto: ScanTargetDto) {
    if (!scanDto.target) {
      throw new BadRequestException('Target is required');
    }

    const startTime = Date.now();

    // Ejecutar escaneos en paralelo
    const [portScanResult, vulnerabilityScanResult] = await Promise.all([
      this.portScannerService.scanHost(scanDto.target),
      this.vulnerabilityScannerService.scanTarget(scanDto.target),
    ]);

    // Analizar vulnerabilidades de puertos
    const portVulnerabilityAnalysis = await this.portScannerService.analyzeVulnerabilities(portScanResult);

    const totalDuration = Date.now() - startTime;

    return {
      target: scanDto.target,
      scanDuration: totalDuration,
      timestamp: new Date(),
      portScan: {
        ...portScanResult,
        vulnerabilityAnalysis: portVulnerabilityAnalysis,
      },
      vulnerabilityScan: vulnerabilityScanResult,
      summary: {
        totalOpenPorts: portScanResult.totalOpenPorts,
        totalVulnerabilities: vulnerabilityScanResult.vulnerabilities.length,
        overallRiskScore: Math.max(
          portVulnerabilityAnalysis.riskLevel === 'HIGH' ? 80 : 
          portVulnerabilityAnalysis.riskLevel === 'MEDIUM' ? 50 : 20,
          vulnerabilityScanResult.riskScore
        ),
        recommendations: [
          ...portVulnerabilityAnalysis.recommendations,
          ...vulnerabilityScanResult.vulnerabilities.map(v => v.recommendation),
        ].filter((v, i, a) => a.indexOf(v) === i), // Remove duplicates
      },
    };
  }

  @Get('scan-status')
  @ApiOperation({
    summary: 'Estado de escaneos',
    description: 'Obtiene el estado de los escaneos en curso',
  })
  @ApiResponse({
    status: 200,
    description: 'Estado de escaneos',
  })
  async getScanStatus() {
    return {
      activeScans: 0, // Implementar tracking de escaneos activos
      lastScan: null,
      scanHistory: [],
    };
  }

  @Get('scan-history')
  @ApiOperation({
    summary: 'Historial de escaneos',
    description: 'Obtiene el historial de escaneos realizados',
  })
  @ApiResponse({
    status: 200,
    description: 'Historial de escaneos',
  })
  async getScanHistory() {
    return {
      scans: [], // Implementar almacenamiento de historial
      totalScans: 0,
    };
  }

  @Post('range-scan')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({
    summary: 'Escaneo de rango de puertos',
    description: 'Escanea un rango específico de puertos',
  })
  @ApiQuery({ name: 'target', description: 'Host objetivo' })
  @ApiQuery({ name: 'startPort', description: 'Puerto inicial', type: Number })
  @ApiQuery({ name: 'endPort', description: 'Puerto final', type: Number })
  @ApiResponse({
    status: 200,
    description: 'Escaneo de rango completado',
  })
  async rangeScan(
    @Query('target') target: string,
    @Query('startPort') startPort: number,
    @Query('endPort') endPort: number,
  ) {
    if (!target || !startPort || !endPort) {
      throw new BadRequestException('Target, startPort, and endPort are required');
    }

    if (startPort < 1 || endPort > 65535 || startPort > endPort) {
      throw new BadRequestException('Invalid port range');
    }

    return await this.portScannerService.rangeScan(target, startPort, endPort);
  }

  @Get('tools')
  @ApiOperation({
    summary: 'Herramientas disponibles',
    description: 'Lista de herramientas de pentesting disponibles',
  })
  @ApiResponse({
    status: 200,
    description: 'Herramientas disponibles',
  })
  async getAvailableTools() {
    return {
      tools: [
        {
          name: 'Port Scanner',
          description: 'Escaneo de puertos y servicios',
          endpoints: ['/pentest/port-scan', '/pentest/range-scan'],
          capabilities: ['TCP Connect', 'Service Detection', 'Banner Grabbing'],
        },
        {
          name: 'Vulnerability Scanner',
          description: 'Escaneo de vulnerabilidades web',
          endpoints: ['/pentest/vulnerability-scan'],
          capabilities: [
            'SQL Injection',
            'XSS',
            'CSRF',
            'Directory Traversal',
            'Command Injection',
            'SSL/TLS Analysis',
            'Security Headers',
            'Open Redirects',
          ],
        },
        {
          name: 'Full Pentest',
          description: 'Pentest completo automatizado',
          endpoints: ['/pentest/full-pentest'],
          capabilities: ['Port Scanning', 'Vulnerability Assessment', 'Risk Analysis'],
        },
      ],
    };
  }
} 