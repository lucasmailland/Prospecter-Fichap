import {
  Controller,
  Post,
  Get,
  Body,
  Query,
  UseGuards,
  HttpCode,
  HttpStatus,
  BadRequestException,
} from '@nestjs/common';
import { ApiTags, ApiOperation, ApiResponse, ApiBearerAuth, ApiQuery } from '@nestjs/swagger';
import { JwtAuthGuard } from '../../auth/guards/jwt-auth.guard';
import { PentestService } from './pentest.service';
import { PortScannerService } from './services/port-scanner.service';
import { VulnerabilityScannerService } from './services/vulnerability-scanner.service';

export class ScanTargetDto {
  target: string;
  scanType?: 'quick' | 'full' | 'custom';
  ports?: number[];
}

export class VulnerabilityScanDto {
  target: string;
  scanTypes?: string[];
}

// SSRF Protection: Validate and sanitize targets
class TargetValidator {
  private static readonly ALLOWED_TARGETS = [
    'localhost',
    '127.0.0.1',
    '::1',
    'testsite.local',
    'demo.local',
    'test.local'
  ];
  
  private static readonly BLOCKED_PATTERNS = [
    /^10\./,           // Private networks
    /^172\.(1[6-9]|2[0-9]|3[0-1])\./,
    /^192\.168\./,
    /^169\.254\./,     // Link-local
    /^224\./,          // Multicast
    /^255\./,          // Broadcast
    /file:\/\//i,      // File protocol
    /ftp:\/\//i,       // FTP protocol
    /gopher:\/\//i,    // Gopher protocol
    /dict:\/\//i,      // Dict protocol
  ];

  static validateTarget(target: string): string {
    if (!target) {
      throw new BadRequestException('Target is required');
    }

    // Remove any protocol prefix and clean input
    const cleanTarget = target.replace(/^https?:\/\//, '').toLowerCase().trim();
    
    // Check if target is in allowed list
    if (this.ALLOWED_TARGETS.includes(cleanTarget)) {
      return cleanTarget;
    }

    // Check for blocked patterns
    for (const pattern of this.BLOCKED_PATTERNS) {
      if (pattern.test(cleanTarget)) {
        throw new BadRequestException(`Target '${cleanTarget}' is not allowed for security reasons`);
      }
    }

    // Additional validation for localhost variations
    if (cleanTarget.includes('localhost') || cleanTarget.includes('127.0.0.1')) {
      return cleanTarget;
    }

    // For any other target, require explicit approval
    throw new BadRequestException(`Target '${cleanTarget}' is not in the approved targets list. Contact administrator to add it.`);
  }

  static sanitizeTarget(target: string): string {
    const validated = this.validateTarget(target);
    
    // Additional sanitization
    return validated
      .replace(/[<>'"&]/g, '') // Remove potential injection chars
      .substring(0, 100);      // Limit length
  }
}

@ApiTags('pentest')
@Controller('pentest')
@UseGuards(JwtAuthGuard)
@ApiBearerAuth()
export class PentestController {
  constructor(
    private readonly pentestService: PentestService,
    private readonly portScannerService: PortScannerService,
    private readonly vulnerabilityScannerService: VulnerabilityScannerService,
  ) {}

  @Post('port-scan')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({
    summary: 'Escaneo de puertos',
    description: 'Realiza un escaneo completo de puertos en un host objetivo',
  })
  @ApiResponse({
    status: 200,
    description: 'Escaneo de puertos completado',
  })
  @ApiResponse({
    status: 400,
    description: 'Target inválido',
  })
  @ApiResponse({
    status: 401,
    description: 'No autorizado',
  })
  async portScan(@Body() scanDto: ScanTargetDto) {
    // SSRF Protection: Validate and sanitize target
    const safeTarget = TargetValidator.sanitizeTarget(scanDto.target);

    let scanResult;
    switch (scanDto.scanType) {
      case 'quick':
        scanResult = await this.portScannerService.quickScan(safeTarget);
        break;
      case 'full':
        scanResult = await this.portScannerService.fullScan(safeTarget);
        break;
      case 'custom':
        if (!scanDto.ports || scanDto.ports.length === 0) {
          throw new BadRequestException('Ports array is required for custom scan');
        }
        scanResult = await this.portScannerService.scanHost(safeTarget, scanDto.ports);
        break;
      default:
        scanResult = await this.portScannerService.scanHost(safeTarget);
    }

    // Analizar vulnerabilidades en puertos abiertos
    const vulnerabilityAnalysis = await this.portScannerService.analyzeVulnerabilities(scanResult);

    return {
      ...scanResult,
      vulnerabilityAnalysis,
    };
  }

  @Post('vulnerability-scan')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({
    summary: 'Escaneo de vulnerabilidades',
    description: 'Realiza un escaneo completo de vulnerabilidades web',
  })
  @ApiResponse({
    status: 200,
    description: 'Escaneo de vulnerabilidades completado',
  })
  @ApiResponse({
    status: 400,
    description: 'Target inválido',
  })
  @ApiResponse({
    status: 401,
    description: 'No autorizado',
  })
  async vulnerabilityScan(@Body() scanDto: VulnerabilityScanDto) {
    // SSRF Protection: Validate and sanitize target
    const safeTarget = TargetValidator.sanitizeTarget(scanDto.target);

    return await this.vulnerabilityScannerService.scanTarget(safeTarget);
  }

  @Post('full-pentest')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({
    summary: 'Pentest completo',
    description: 'Realiza un pentest completo incluyendo escaneo de puertos y vulnerabilidades',
  })
  @ApiResponse({
    status: 200,
    description: 'Pentest completo finalizado',
  })
  @ApiResponse({
    status: 400,
    description: 'Target inválido',
  })
  @ApiResponse({
    status: 401,
    description: 'No autorizado',
  })
  async fullPentest(@Body() scanDto: ScanTargetDto) {
    // SSRF Protection: Validate and sanitize target
    const safeTarget = TargetValidator.sanitizeTarget(scanDto.target);

    const startTime = Date.now();

    // Ejecutar escaneos en paralelo
    const [portScanResult, vulnerabilityScanResult] = await Promise.all([
      this.portScannerService.scanHost(safeTarget),
      this.vulnerabilityScannerService.scanTarget(safeTarget),
    ]);

    // Analizar vulnerabilidades de puertos
    const portVulnerabilityAnalysis = await this.portScannerService.analyzeVulnerabilities(portScanResult);

    const totalDuration = Date.now() - startTime;

    return {
      target: safeTarget,
      scanDuration: totalDuration,
      timestamp: new Date(),
      portScan: {
        ...portScanResult,
        vulnerabilityAnalysis: portVulnerabilityAnalysis,
      },
      vulnerabilityScan: vulnerabilityScanResult,
      summary: {
        totalOpenPorts: portScanResult.totalOpenPorts,
        totalVulnerabilities: vulnerabilityScanResult.vulnerabilities.length,
        overallRiskScore: Math.max(
          portVulnerabilityAnalysis.riskLevel === 'HIGH' ? 80 : 
          portVulnerabilityAnalysis.riskLevel === 'MEDIUM' ? 50 : 20,
          vulnerabilityScanResult.riskScore
        ),
        recommendations: [
          ...portVulnerabilityAnalysis.recommendations,
          ...vulnerabilityScanResult.vulnerabilities.map(v => v.recommendation),
        ].filter((v, i, a) => a.indexOf(v) === i), // Remove duplicates
      },
    };
  }

  @Get('scan-status')
  @ApiOperation({
    summary: 'Estado de escaneos',
    description: 'Obtiene el estado de los escaneos en curso',
  })
  @ApiResponse({
    status: 200,
    description: 'Estado de escaneos',
  })
  async getScanStatus() {
    return {
      activeScans: 0, // Implementar tracking de escaneos activos
      lastScan: null,
      scanHistory: [],
    };
  }

  @Get('scan-history')
  @ApiOperation({
    summary: 'Historial de escaneos',
    description: 'Obtiene el historial de escaneos realizados',
  })
  @ApiResponse({
    status: 200,
    description: 'Historial de escaneos',
  })
  async getScanHistory() {
    return {
      scans: [], // Implementar almacenamiento de historial
      totalScans: 0,
    };
  }

  @Post('range-scan')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({
    summary: 'Escaneo de rango de puertos',
    description: 'Escanea un rango específico de puertos',
  })
  @ApiQuery({ name: 'target', description: 'Host objetivo' })
  @ApiQuery({ name: 'startPort', description: 'Puerto inicial', type: Number })
  @ApiQuery({ name: 'endPort', description: 'Puerto final', type: Number })
  @ApiResponse({
    status: 200,
    description: 'Escaneo de rango completado',
  })
  async rangeScan(
    @Query('target') target: string,
    @Query('startPort') startPort: number,
    @Query('endPort') endPort: number,
  ) {
    // SSRF Protection: Validate and sanitize target
    const safeTarget = TargetValidator.sanitizeTarget(target);

    if (!startPort || !endPort) {
      throw new BadRequestException('Target, startPort, and endPort are required');
    }

    if (startPort < 1 || endPort > 65535 || startPort > endPort) {
      throw new BadRequestException('Invalid port range');
    }

    return await this.portScannerService.rangeScan(safeTarget, startPort, endPort);
  }

  @Get('tools')
  @ApiOperation({
    summary: 'Herramientas disponibles',
    description: 'Lista de herramientas de pentesting disponibles',
  })
  @ApiResponse({
    status: 200,
    description: 'Herramientas disponibles',
  })
  async getAvailableTools() {
    return {
      tools: [
        {
          name: 'Port Scanner',
          description: 'Escaneo de puertos y servicios',
          endpoints: ['/pentest/port-scan', '/pentest/range-scan'],
          capabilities: ['TCP Connect', 'Service Detection', 'Banner Grabbing'],
          allowedTargets: TargetValidator['ALLOWED_TARGETS'],
        },
        {
          name: 'Vulnerability Scanner',
          description: 'Escaneo de vulnerabilidades web',
          endpoints: ['/pentest/vulnerability-scan'],
          capabilities: [
            'SQL Injection',
            'XSS',
            'CSRF',
            'Directory Traversal',
            'Command Injection',
            'SSL/TLS Analysis',
            'Security Headers',
            'Open Redirects',
          ],
          allowedTargets: TargetValidator['ALLOWED_TARGETS'],
        },
        {
          name: 'Full Pentest',
          description: 'Pentest completo automatizado',
          endpoints: ['/pentest/full-pentest'],
          capabilities: ['Port Scanning', 'Vulnerability Assessment', 'Risk Analysis'],
          allowedTargets: TargetValidator['ALLOWED_TARGETS'],
        },
      ],
      securityNotice: 'All targets are validated against an allowed list for security reasons. Contact administrator to add new targets.',
    };
  }
} 