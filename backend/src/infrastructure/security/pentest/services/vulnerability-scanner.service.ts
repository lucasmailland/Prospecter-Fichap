import { Injectable, Logger } from '@nestjs/common';
import axios from 'axios';
import * as crypto from 'crypto';

export interface VulnerabilityResult {
  type: string;
  severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
  description: string;
  evidence: string;
  cve?: string;
  recommendation: string;
  timestamp: Date;
}

export interface SecurityScanResult {
  target: string;
  vulnerabilities: VulnerabilityResult[];
  riskScore: number;
  scanDuration: number;
  timestamp: Date;
}

@Injectable()
export class VulnerabilityScannerService {
  private readonly logger = new Logger(VulnerabilityScannerService.name);

  /**
   * Escaneo completo de vulnerabilidades
   */
  async scanTarget(target: string): Promise<SecurityScanResult> {
    const startTime = Date.now();
    this.logger.log(`🔍 Starting vulnerability scan for: ${target}`);

    const vulnerabilities: VulnerabilityResult[] = [];

    // Escaneos paralelos
    const scanPromises = [
      this.scanSQLInjection(target),
      this.scanXSS(target),
      this.scanCSRF(target),
      this.scanDirectoryTraversal(target),
      this.scanCommandInjection(target),
      this.scanSSLVulnerabilities(target),
      this.scanHeaders(target),
      this.scanOpenRedirects(target),
    ];

    const results = await Promise.allSettled(scanPromises);
    
    results.forEach(result => {
      if (result.status === 'fulfilled' && result.value) {
        vulnerabilities.push(...result.value);
      }
    });

    const riskScore = this.calculateRiskScore(vulnerabilities);
    const scanDuration = Date.now() - startTime;

    this.logger.log(`✅ Vulnerability scan completed: ${vulnerabilities.length} issues found`);

    return {
      target,
      vulnerabilities,
      riskScore,
      scanDuration,
      timestamp: new Date(),
    };
  }

  /**
   * Escaneo de SQL Injection
   */
  private async scanSQLInjection(target: string): Promise<VulnerabilityResult[]> {
    const vulnerabilities: VulnerabilityResult[] = [];
    const payloads = [
      "' OR '1'='1",
      "'; DROP TABLE users; --",
      "' UNION SELECT NULL--",
      "admin'--",
      "1' AND 1=1--",
    ];

    try {
      for (const payload of payloads) {
        const response = await axios.get(`${target}?id=${encodeURIComponent(payload)}`, {
          timeout: 5000,
          validateStatus: () => true,
        });

        if (this.detectSQLInjection(response)) {
          vulnerabilities.push({
            type: 'SQL_INJECTION',
            severity: 'CRITICAL',
            description: 'SQL Injection vulnerability detected',
            evidence: `Payload: ${payload}, Response: ${response.status}`,
            recommendation: 'Use parameterized queries and input validation',
            timestamp: new Date(),
          });
        }
      }
    } catch (error) {
      this.logger.warn(`SQL Injection scan failed: ${error.message}`);
    }

    return vulnerabilities;
  }

  /**
   * Escaneo de XSS
   */
  private async scanXSS(target: string): Promise<VulnerabilityResult[]> {
    const vulnerabilities: VulnerabilityResult[] = [];
    const payloads = [
      '<script>alert("XSS")</script>',
      'javascript:alert("XSS")',
      '<img src=x onerror=alert("XSS")>',
      '"><script>alert("XSS")</script>',
    ];

    try {
      for (const payload of payloads) {
        const response = await axios.get(`${target}?search=${encodeURIComponent(payload)}`, {
          timeout: 5000,
          validateStatus: () => true,
        });

        if (response.data.includes(payload)) {
          vulnerabilities.push({
            type: 'XSS',
            severity: 'HIGH',
            description: 'Cross-Site Scripting vulnerability detected',
            evidence: `Payload: ${payload}`,
            recommendation: 'Implement proper input sanitization and output encoding',
            timestamp: new Date(),
          });
        }
      }
    } catch (error) {
      this.logger.warn(`XSS scan failed: ${error.message}`);
    }

    return vulnerabilities;
  }

  /**
   * Escaneo de CSRF
   */
  private async scanCSRF(target: string): Promise<VulnerabilityResult[]> {
    const vulnerabilities: VulnerabilityResult[] = [];

    try {
      const response = await axios.get(target, {
        timeout: 5000,
        validateStatus: () => true,
      });

      const csrfToken = this.extractCSRFToken(response.data);
      
      if (!csrfToken) {
        vulnerabilities.push({
          type: 'CSRF',
          severity: 'MEDIUM',
          description: 'No CSRF protection detected',
          evidence: 'No CSRF token found in response',
          recommendation: 'Implement CSRF tokens for all state-changing operations',
          timestamp: new Date(),
        });
      }
    } catch (error) {
      this.logger.warn(`CSRF scan failed: ${error.message}`);
    }

    return vulnerabilities;
  }

  /**
   * Escaneo de Directory Traversal
   */
  private async scanDirectoryTraversal(target: string): Promise<VulnerabilityResult[]> {
    const vulnerabilities: VulnerabilityResult[] = [];
    const payloads = [
      '../../../etc/passwd',
      '..\\..\\windows\\system32\\config\\sam',
      '%2e%2e%2f%2e%2e%2fetc%2fpasswd',
    ];

    try {
      for (const payload of payloads) {
        const response = await axios.get(`${target}?file=${encodeURIComponent(payload)}`, {
          timeout: 5000,
          validateStatus: () => true,
        });

        if (this.detectDirectoryTraversal(response)) {
          vulnerabilities.push({
            type: 'DIRECTORY_TRAVERSAL',
            severity: 'HIGH',
            description: 'Directory traversal vulnerability detected',
            evidence: `Payload: ${payload}`,
            recommendation: 'Validate and sanitize file paths',
            timestamp: new Date(),
          });
        }
      }
    } catch (error) {
      this.logger.warn(`Directory traversal scan failed: ${error.message}`);
    }

    return vulnerabilities;
  }

  /**
   * Escaneo de Command Injection
   */
  private async scanCommandInjection(target: string): Promise<VulnerabilityResult[]> {
    const vulnerabilities: VulnerabilityResult[] = [];
    const payloads = [
      '; ls -la',
      '& whoami',
      '| cat /etc/passwd',
      '`id`',
    ];

    try {
      for (const payload of payloads) {
        const response = await axios.get(`${target}?cmd=${encodeURIComponent(payload)}`, {
          timeout: 5000,
          validateStatus: () => true,
        });

        if (this.detectCommandInjection(response)) {
          vulnerabilities.push({
            type: 'COMMAND_INJECTION',
            severity: 'CRITICAL',
            description: 'Command injection vulnerability detected',
            evidence: `Payload: ${payload}`,
            recommendation: 'Use parameterized commands and input validation',
            timestamp: new Date(),
          });
        }
      }
    } catch (error) {
      this.logger.warn(`Command injection scan failed: ${error.message}`);
    }

    return vulnerabilities;
  }

  /**
   * Escaneo de vulnerabilidades SSL/TLS
   */
  private async scanSSLVulnerabilities(target: string): Promise<VulnerabilityResult[]> {
    const vulnerabilities: VulnerabilityResult[] = [];

    try {
      if (target.startsWith('https://')) {
        const response = await axios.get(target, {
          timeout: 5000,
          validateStatus: () => true,
        });

        // Verificar headers de seguridad
        const securityHeaders = response.headers;
        
        if (!securityHeaders['strict-transport-security']) {
          vulnerabilities.push({
            type: 'MISSING_HSTS',
            severity: 'MEDIUM',
            description: 'Missing HSTS header',
            evidence: 'No Strict-Transport-Security header found',
            recommendation: 'Implement HSTS header for HTTPS sites',
            timestamp: new Date(),
          });
        }

        if (!securityHeaders['x-frame-options']) {
          vulnerabilities.push({
            type: 'MISSING_XFO',
            severity: 'MEDIUM',
            description: 'Missing X-Frame-Options header',
            evidence: 'No X-Frame-Options header found',
            recommendation: 'Implement X-Frame-Options to prevent clickjacking',
            timestamp: new Date(),
          });
        }
      } else {
        vulnerabilities.push({
          type: 'NO_HTTPS',
          severity: 'HIGH',
          description: 'Site not using HTTPS',
          evidence: 'HTTP protocol detected',
          recommendation: 'Implement HTTPS with valid SSL certificate',
          timestamp: new Date(),
        });
      }
    } catch (error) {
      this.logger.warn(`SSL scan failed: ${error.message}`);
    }

    return vulnerabilities;
  }

  /**
   * Escaneo de headers de seguridad
   */
  private async scanHeaders(target: string): Promise<VulnerabilityResult[]> {
    const vulnerabilities: VulnerabilityResult[] = [];

    try {
      const response = await axios.get(target, {
        timeout: 5000,
        validateStatus: () => true,
      });

      const headers = response.headers;
      const requiredHeaders = {
        'x-content-type-options': 'nosniff',
        'x-xss-protection': '1; mode=block',
        'referrer-policy': 'strict-origin-when-cross-origin',
      };

      for (const [header, expectedValue] of Object.entries(requiredHeaders)) {
        if (!headers[header] || !headers[header].includes(expectedValue)) {
          vulnerabilities.push({
            type: 'MISSING_SECURITY_HEADER',
            severity: 'LOW',
            description: `Missing or incorrect ${header} header`,
            evidence: `Expected: ${expectedValue}, Found: ${headers[header] || 'none'}`,
            recommendation: `Implement proper ${header} header`,
            timestamp: new Date(),
          });
        }
      }
    } catch (error) {
      this.logger.warn(`Headers scan failed: ${error.message}`);
    }

    return vulnerabilities;
  }

  /**
   * Escaneo de Open Redirects
   */
  private async scanOpenRedirects(target: string): Promise<VulnerabilityResult[]> {
    const vulnerabilities: VulnerabilityResult[] = [];
    const payloads = [
      'https://evil.com',
      '//evil.com',
      'javascript:alert("redirect")',
    ];

    try {
      for (const payload of payloads) {
        const response = await axios.get(`${target}?redirect=${encodeURIComponent(payload)}`, {
          timeout: 5000,
          validateStatus: () => true,
          maxRedirects: 0,
        });

        if (response.status === 302 || response.status === 301) {
          const location = response.headers.location;
          if (location && location.includes('evil.com')) {
            vulnerabilities.push({
              type: 'OPEN_REDIRECT',
              severity: 'MEDIUM',
              description: 'Open redirect vulnerability detected',
              evidence: `Redirect to: ${location}`,
              recommendation: 'Validate redirect URLs against whitelist',
              timestamp: new Date(),
            });
          }
        }
      }
    } catch (error) {
      this.logger.warn(`Open redirect scan failed: ${error.message}`);
    }

    return vulnerabilities;
  }

  /**
   * Detecta SQL Injection en respuesta
   */
  private detectSQLInjection(response: any): boolean {
    const sqlErrors = [
      'sql syntax',
      'mysql_fetch',
      'oracle error',
      'postgresql error',
      'sqlite error',
      'microsoft ole db provider',
    ];

    const responseText = response.data?.toString().toLowerCase() || '';
    return sqlErrors.some(error => responseText.includes(error));
  }

  /**
   * Detecta Directory Traversal en respuesta
   */
  private detectDirectoryTraversal(response: any): boolean {
    const traversalIndicators = [
      'root:x:0:0',
      'bin:x:1:1',
      'daemon:x:2:2',
      'sys:x:3:3',
    ];

    const responseText = response.data?.toString() || '';
    return traversalIndicators.some(indicator => responseText.includes(indicator));
  }

  /**
   * Detecta Command Injection en respuesta
   */
  private detectCommandInjection(response: any): boolean {
    const commandIndicators = [
      'uid=',
      'gid=',
      'groups=',
      'total ',
      'drwx',
    ];

    const responseText = response.data?.toString() || '';
    return commandIndicators.some(indicator => responseText.includes(indicator));
  }

  /**
   * Extrae token CSRF del HTML
   */
  private extractCSRFToken(html: string): string | null {
    const csrfPatterns = [
      /<input[^>]*name=["']_token["'][^>]*value=["']([^"']+)["']/i,
      /<input[^>]*name=["']csrf_token["'][^>]*value=["']([^"']+)["']/i,
      /<meta[^>]*name=["']csrf-token["'][^>]*content=["']([^"']+)["']/i,
    ];

    for (const pattern of csrfPatterns) {
      const match = html.match(pattern);
      if (match) {
        return match[1];
      }
    }

    return null;
  }

  /**
   * Calcula puntuación de riesgo
   */
  private calculateRiskScore(vulnerabilities: VulnerabilityResult[]): number {
    const severityScores = {
      'LOW': 1,
      'MEDIUM': 3,
      'HIGH': 7,
      'CRITICAL': 10,
    };

    const totalScore = vulnerabilities.reduce((score, vuln) => {
      return score + (severityScores[vuln.severity] || 0);
    }, 0);

    // Normalizar a escala 0-100
    return Math.min(100, Math.round((totalScore / 50) * 100));
  }
} 