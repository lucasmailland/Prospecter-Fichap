import { Injectable, Logger } from '@nestjs/common';
import { PortScannerService, NetworkScanResult } from './services/port-scanner.service';
import { VulnerabilityScannerService, SecurityScanResult } from './services/vulnerability-scanner.service';

export interface PentestReport {
  target: string;
  scanId: string;
  timestamp: Date;
  scanDuration: number;
  portScan: NetworkScanResult;
  vulnerabilityScan: SecurityScanResult;
  summary: {
    totalOpenPorts: number;
    totalVulnerabilities: number;
    overallRiskScore: number;
    riskLevel: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
    recommendations: string[];
    criticalIssues: number;
    highIssues: number;
    mediumIssues: number;
    lowIssues: number;
  };
  details: {
    openPorts: any[];
    vulnerabilities: any[];
    securityHeaders: any[];
    sslAnalysis: any;
  };
}

@Injectable()
export class PentestService {
  private readonly logger = new Logger(PentestService.name);
  private activeScans = new Map<string, any>();

  constructor(
    private readonly portScannerService: PortScannerService,
    private readonly vulnerabilityScannerService: VulnerabilityScannerService,
  ) {}

  /**
   * Ejecuta un pentest completo
   */
  async runFullPentest(target: string): Promise<PentestReport> {
    const scanId = this.generateScanId();
    const startTime = Date.now();

    this.logger.log(`üöÄ Starting full pentest for ${target} (ID: ${scanId})`);

    try {
      // Ejecutar escaneos en paralelo
      const [portScanResult, vulnerabilityScanResult] = await Promise.all([
        this.portScannerService.scanHost(target),
        this.vulnerabilityScannerService.scanTarget(target),
      ]);

      // Analizar vulnerabilidades de puertos
      const portVulnerabilityAnalysis = await this.portScannerService.analyzeVulnerabilities(portScanResult);

      const scanDuration = Date.now() - startTime;

      // Generar reporte completo
      const report = this.generateReport(
        scanId,
        target,
        scanDuration,
        portScanResult,
        vulnerabilityScanResult,
        portVulnerabilityAnalysis,
      );

      this.logger.log(`‚úÖ Pentest completed for ${target} in ${scanDuration}ms`);
      return report;

    } catch (error) {
      this.logger.error(`‚ùå Pentest failed for ${target}: ${error.message}`);
      throw error;
    }
  }

  /**
   * Escaneo r√°pido de seguridad
   */
  async runQuickSecurityScan(target: string): Promise<any> {
    const scanId = this.generateScanId();
    const startTime = Date.now();

    this.logger.log(`üîç Starting quick security scan for ${target}`);

    try {
      // Solo escaneo de puertos comunes y vulnerabilidades b√°sicas
      const portScanResult = await this.portScannerService.quickScan(target);
      const vulnerabilityScanResult = await this.vulnerabilityScannerService.scanTarget(target);

      const scanDuration = Date.now() - startTime;

      return {
        scanId,
        target,
        scanDuration,
        timestamp: new Date(),
        portScan: portScanResult,
        vulnerabilityScan: vulnerabilityScanResult,
        summary: {
          totalOpenPorts: portScanResult.totalOpenPorts,
          totalVulnerabilities: vulnerabilityScanResult.vulnerabilities.length,
          riskLevel: this.calculateOverallRiskLevel(vulnerabilityScanResult.riskScore, portScanResult.totalOpenPorts),
        },
      };

    } catch (error) {
      this.logger.error(`‚ùå Quick scan failed for ${target}: ${error.message}`);
      throw error;
    }
  }

  /**
   * Escaneo de vulnerabilidades espec√≠ficas
   */
  async runVulnerabilityScan(target: string, scanTypes?: string[]): Promise<SecurityScanResult> {
    this.logger.log(`üîç Starting vulnerability scan for ${target}`);
    return await this.vulnerabilityScannerService.scanTarget(target);
  }

  /**
   * Escaneo de puertos espec√≠ficos
   */
  async runPortScan(target: string, ports?: number[]): Promise<NetworkScanResult> {
    this.logger.log(`üîç Starting port scan for ${target}`);
    return await this.portScannerService.scanHost(target, ports);
  }

  /**
   * Genera reporte completo de pentest
   */
  private generateReport(
    scanId: string,
    target: string,
    scanDuration: number,
    portScanResult: NetworkScanResult,
    vulnerabilityScanResult: SecurityScanResult,
    portVulnerabilityAnalysis: any,
  ): PentestReport {
    const openPorts = portScanResult.ports.filter(p => p.status === 'open');
    const vulnerabilities = vulnerabilityScanResult.vulnerabilities;

    // Contar vulnerabilidades por severidad
    const criticalIssues = vulnerabilities.filter(v => v.severity === 'CRITICAL').length;
    const highIssues = vulnerabilities.filter(v => v.severity === 'HIGH').length;
    const mediumIssues = vulnerabilities.filter(v => v.severity === 'MEDIUM').length;
    const lowIssues = vulnerabilities.filter(v => v.severity === 'LOW').length;

    // Calcular puntuaci√≥n de riesgo general
    const overallRiskScore = Math.max(
      portVulnerabilityAnalysis.riskLevel === 'HIGH' ? 80 : 
      portVulnerabilityAnalysis.riskLevel === 'MEDIUM' ? 50 : 20,
      vulnerabilityScanResult.riskScore
    );

    // Generar recomendaciones √∫nicas
    const recommendations = [
      ...portVulnerabilityAnalysis.recommendations,
      ...vulnerabilities.map(v => v.recommendation),
    ].filter((v, i, a) => a.indexOf(v) === i);

    return {
      target,
      scanId,
      timestamp: new Date(),
      scanDuration,
      portScan: portScanResult,
      vulnerabilityScan: vulnerabilityScanResult,
      summary: {
        totalOpenPorts: openPorts.length,
        totalVulnerabilities: vulnerabilities.length,
        overallRiskScore,
        riskLevel: this.calculateRiskLevel(overallRiskScore),
        recommendations,
        criticalIssues,
        highIssues,
        mediumIssues,
        lowIssues,
      },
      details: {
        openPorts: openPorts.map(port => ({
          port: port.port,
          service: port.service,
          banner: port.banner,
          vulnerability: portVulnerabilityAnalysis.vulnerabilities.find(v => v.port === port.port),
        })),
        vulnerabilities: vulnerabilities.map(vuln => ({
          type: vuln.type,
          severity: vuln.severity,
          description: vuln.description,
          evidence: vuln.evidence,
          recommendation: vuln.recommendation,
        })),
        securityHeaders: this.analyzeSecurityHeaders(vulnerabilityScanResult),
        sslAnalysis: this.analyzeSSL(vulnerabilityScanResult),
      },
    };
  }

  /**
   * Analiza headers de seguridad
   */
  private analyzeSecurityHeaders(vulnerabilityScanResult: SecurityScanResult): any[] {
    const headerVulns = vulnerabilityScanResult.vulnerabilities.filter(
      v => v.type.includes('HEADER') || v.type.includes('HSTS') || v.type.includes('XFO')
    );

    return headerVulns.map(vuln => ({
      header: vuln.type.replace('MISSING_', ''),
      status: 'MISSING',
      severity: vuln.severity,
      recommendation: vuln.recommendation,
    }));
  }

  /**
   * Analiza configuraci√≥n SSL/TLS
   */
  private analyzeSSL(vulnerabilityScanResult: SecurityScanResult): any {
    const sslVulns = vulnerabilityScanResult.vulnerabilities.filter(
      v => v.type.includes('SSL') || v.type.includes('HTTPS')
    );

    return {
      hasSSL: !sslVulns.some(v => v.type === 'NO_HTTPS'),
      vulnerabilities: sslVulns.map(vuln => ({
        type: vuln.type,
        severity: vuln.severity,
        description: vuln.description,
        recommendation: vuln.recommendation,
      })),
    };
  }

  /**
   * Calcula nivel de riesgo general
   */
  private calculateOverallRiskLevel(vulnerabilityScore: number, openPorts: number): string {
    const portRisk = openPorts > 10 ? 70 : openPorts > 5 ? 50 : 20;
    const totalRisk = Math.max(vulnerabilityScore, portRisk);

    return this.calculateRiskLevel(totalRisk);
  }

  /**
   * Calcula nivel de riesgo basado en puntuaci√≥n
   */
  private calculateRiskLevel(score: number): 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL' {
    if (score >= 80) return 'CRITICAL';
    if (score >= 60) return 'HIGH';
    if (score >= 30) return 'MEDIUM';
    return 'LOW';
  }

  /**
   * Genera ID √∫nico para escaneo
   */
  private generateScanId(): string {
    return `pentest_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * Obtiene estad√≠sticas de pentesting
   */
  getPentestStats(): any {
    return {
      activeScans: this.activeScans.size,
      totalScans: 0, // Implementar contador total
      averageScanDuration: 0, // Implementar c√°lculo
      mostScannedTargets: [], // Implementar tracking
    };
  }
} 